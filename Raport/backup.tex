\documentclass[10pt,a4paper, norsk]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[norsk, english]{babel}
\usepackage{geometry, lmodern}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage{color}
\usepackage[colorlinks=true,linkcolor=black,citecolor=black]{hyperref}
\author{Simen Haugerud Granlund}
\title{TMR4162 - Ramme Analyse}

\hypersetup{
pdfauthor = {Simen Haugerud Granlund},
pdftitle = {TMR4162 - Ramme Analyse},
pdfsubject = {},
pdfkeywords = {},
pdfcreator = {} } 

\begin{document}
\maketitle
\lstset{language=C++,basicstyle=\footnotesize} %\begin{titlepage}
\maketitle
\thispagestyle{empty} 	%fjerner sidetall på første side
\newpage %\end{titlepage}

\section*{Innledning}
\paragraph*{}
Jeg valgte å ta oppgaven "ramme analyse". Grunnen til dette er at jeg synes teorien rundt finite element analyses (FEA) er mye mer interessent og passer bedre til mitt studie enn Poisson-likningen. Jeg valgte også å legge til flere elementer i oppgaven. Oppgaven presiserte at vi bare trengte 2 frihetsgrader per bjelke, samt at vi kun trengte å presentere resultater for bøyemomentet. Jeg valgte å bruke 6 frihetsgrader per bjelke, slik at jeg fikk meg både  vertikal og horisontal forskyvninger og rotasjon. De resultatene jeg ville skulle vises var; Moment diagram, skjærkraft diagram, Normalkraft diagram og starttilstanden. Til dette trenger programmet å regne ut Momenter og normale og aksielle krefter til alle bjelker.

\paragraph*{}
Det jeg ville legge mest vekt må under oppgaven var god struktur av koden slik at jeg enkelt kan utvide med nye funksjonaliteter. Med en god struktur er det enkelt å sette seg inn i koden og en slipper å strukturere mye på nytt om en vil legge til nye funksjonaliteter. Jeg liker generelt ikke mye kommentarer i koden. Koden skal være leselig og forstålig uten en hel haug av kommentarer. Selvfølgelig er det steder hvor kommentarer er passende, men generelt holder det med god struktur og navngiving.


\section*{Teori}

Her har jeg tenkt å kort beskrive de teoriene som er brukt i programmet. Jeg vil kun ta med de prinsippene, likningene og matrisene jeg brukte i koden og ikke beskrive i detalj hvordan jeg kan frem til dem basert på lærebøker. 


\subsection*{Elementmetoden}
Teorien bak elementmetoden ble utarbeidet på 1940-tallet, men man så ikke den store nytteverdien av den før datamaskinen kom til verden. Det første programmet som implementerte elementmetoden var NASTRAN skrevet i Fortran i 1965 \cite{wikinastran}.
Elementmetoden er i prinsippet en numerisk metode for å finne approksimasjoner til differensiallikninger. Den er ofte brukt innenfor en rekke felter: strømning, varmeleding, svinginger, elektriske felt og liknende. I denne oppgaven brukte jeg den for å løse styrkebergnegrer på en rammekonstruksjon. 

\paragraph*{}
Elementmetoden går ut på å dele konstruksjonen inn i elementer, jo flere elementer jo mer nøyaktige resultater får man. For hvert element blir stivheten til elementet kalkulert. Stivheten er basert på e-modulen, arealet og det andre arealmomentet til elementet. Disse stivhetene blir så addert sammen for å finne systemets stivhet. Vi kan deretter bruke sammenhangen mellom stivhet(k), forskyvninger(v) og krefter(S) \eqref{eq:skv} til å kalkulere knutepunktenes forskyvninger.
\begin{equation} \label{eq:skv}
S=k*v
\end{equation}

\subsubsection*{Lokal stivhetsmatrise}
For å regne ut den lokale stivheten til et element kan en bruke stivhetsmatrisen \eqref{eq:Lstivhet}. 

\begin{equation} \label{eq:Lstivhet}
k  = \begin{bmatrix} 
\frac{EA}{L} & 0 & 0 & -\frac{EA}{L} & 0 & 0 \\
0 	& \frac{12EI}{L^3} & -\frac{6EI}{L^2} & 0 & -\frac{12EI}{L^3} & -\frac{6EI}{L^2} \\
0 	&	-\frac{6EI}{L^2} 	& 	\frac{4EI}{L} & 0 & \frac{6EI}{L^2} 	& 	\frac{2EI}{L}\\
-\frac{EA}{L} & 0 & 0 & \frac{EA}{L} & 0 & 0 \\
0 	& -\frac{12EI}{L^3} & \frac{6EI}{L^2} & 0 & \frac{12EI}{L^3} & \frac{6EI}{L^2} \\
0 & -\frac{6EI}{L^2} & \frac{2EI}{L} &0& \frac{6EI}{L^2} & \frac{4EI}{L}
\end{bmatrix}
\end{equation}




Denne stivhetsmatrisen vil nå gjelde for lokalt for det enkelte elementet. Vi må derfor transformere matrisen slik at den gjelder globalt. Dette kan vi gjøre med en enkel rotasjonsmatrise \eqref{eq:Rot}. 

\begin{equation} \label{eq:Rot}
R  = \begin{bmatrix}
\cos \theta & -\sin \theta &   0&0&0&0\\[3pt]
\sin \theta & \cos \theta  & 0&0&0&0\\[3pt]
0 &0 & 1&0&0&0\\
0&0&0&\cos \theta & -\sin \theta&   0 \\[3pt]
0&0&0&\sin \theta & \cos \theta  & 0\\[3pt]
0&0&0&0 &0 & 1\\
\end{bmatrix} 
\end{equation}

Vi kan enkelt transformere kreftene $S$ og forskyvningene $v$ ved sammenhengene:
\begin{equation} \label{eq:roteq}
S_G=RS_L  \text{ og } v_G=Rv_L 
\end{equation}

Vi kan nå ved hjelp av \ref{eq:skv} og \ref{eq:roteq} finne en sammenheng mellom den globale $_G$ og den lokale $_L$ stivhetsmatrisen.

\begin{equation}
S_G=RS_L=Rk_Lv_L=Rk_LR^{-1}v_G=k_Gv_G 
\end{equation}
\begin{equation} \label{eq:klkg}
k_G=Rk_LR^{-1}
\end{equation}

\subsubsection*{Global stivhetsmatrise}
For å addere alle elementstivhetsmatrisene til en global stivhetsmatrise er det normalt å bruke en IEG-matrise. IEG-matrisen er en relasjon mellom elementene og det tilhørende nodeparret. Den globale stivhetsmatrisen holder på stivhetene til alle nodene i systemet, mens de enkelte elementstivhetsmatrise inneholder kun stivheten til sine to tilhørende noder. Når de skal adderes skal stivhetene til elementstivhetsmatrisene adderes inn i de tilhørende nodene i den globale stivhetsmatrisen. 

\subsubsection*{Grensebetingelser}
Nå står vi bare igjen med et lineært ligningssystem av typen $kv=S$, hvor forskyvningene $(v)$ er ukjente. Dette likningssystemet vil nå være uløselig, fordi stivhetsmatrisen $k$ er singulær. Denne singulariteten skyldes at vi enda ikke har sakt hvor konstruksjonen er fastbundet. For et system med 3 frihetsgrader per node trenger vi 3 fastbuende frihetsgrader. Når vi har innført disse grensebetingelsene vil systemet være løselig.

\subsubsection*{Elementkrefter}
Når vi vil regne ut krefter på de forskjellige elementene kan vi igjen bruke ligning \ref{eq:skv}. Vi må nå huske at vi må transformere matrisene til det koordinatsystemet vi ønsker. 


\subsection*{Ligningsløser}'
Når man skal modellere mange fysiske og interiørmessigere problemer kan en nesten ikke unngå å løse store linear ligningssystem. Det finnes derfor mange forskjellige metoder å løse disse på og alle har visse fordeler og ulemper.
Det finnes to kategorier av ligningsløsere: dirkete og iterative. De direkte løser settet eksakt, men bruker ofte lenger tid en en iterativ løser. Gauss metoden er et eksempel på en direkteløser. En iterativ løser finner en approksimasjon av løsningen, og kan ha problemer med konvergens i visse tilfeller. 

\subsubsection*{Gauss}

Gauss metoden består av to deler. Den ene er eliminasjon, hvor du utfører elementære rad operasjoner til du for en triangulær form. Deretter gjøres en tilbakesubstitusjon for å finne x-verdiene. De finnes i hovedsak 3 forskjellige rad operasjoner:
\begin{enumerate}
\item Multiplisere en rad med et tall som ikke er null.
\item Addere to rader
\item Bytte om to rader
\end{enumerate}

Kjøretiden til gauss kan kalkuleres ut i fra antall iterasjoner som gjøres. Om vi antar det er $n$ likninger som skal løses kan kjøretiden kalkuleres som vist i \eqref{eq:gausstid}.

\begin{equation} \label{eq:gausstid}
E(n) = \sum_{k=1}^{n-1} (n-k) + 2 \sum_{k=1}^{n-1} (n-k)(n-k-1) = O(n^3)
\end{equation}

På samme måte kan vi kalkulere kjøretiden til tilbakesubstitusjonen:
\begin{equation} \label{eq:gaussseideltid}
T(n) = 2\sum_{i=1}^{n} (n-i) + n = O(n^2)
\end{equation}


\subsubsection*{Gauss-Seidel}
Gauss-seidel er en iterativ ligningsløser, som fungerer best på spinkle matriser. Den har en iterativ del, beskrevet i likning \ref{eq:gauss-seidel}. I hver iterasjon bruker Gauss-Seidel  den forrige utregnede verdien, som gjør at den ikke kan kjøre parallelt. 
 
 \begin{equation} \label{seideliterater}
   x_j^{m+1} = \frac{1}{a_{jj}}  (b_j - \sum_{k=1}^{j-1} a_{jk} x_k^{m+1} - \sum_{k=j+1}^n a_{jk}x^m)
 \end{equation}

Her kan vi ikke finne kjøretiden på samme måte som ved en direkteløser, siden vi hele tiden kan forbedre resultatet ved å kjøre en iterasjon til. Vi må derfor se på konvergens, parallellitet og hvilken nøyaktighet man skal ha. Det finnes noen enkle konvergeringsregler for Gauss-Seidel, som sier at metoden garantert konvergerer om:
\begin{enumerate}
\item Matrisen (A) er strengt eller uavvendelige diagonalt dominerende.
\item Matrisen (A) er positive bestemt (Positive-definite)
\end{enumerate}file:///home/simenhg/invece%20kinematics/inverceKinematics.tex



\subsection*{OpenGL}
Opengl er et API for å rendre 2d og 3d grafikk. Mange av kallene går rett på GPU'en, slik at vi får økt ytelsen. Strukturen er bygget opp som en tilstandsmaskin, hvor vi hele tiden forandrer tilstanden til programmet. Vi kan for eksempel sette hvilken farge eller linjetykkelse som skal brukes videre, ved kommandoene glColor3f() og glLineWith().

\paragraph*{}
OpenGL opererer med en stakk av 3 matriser, hvor do på hver matrise kan utføre rotasjoner, forskyvninger og skaleringer. Hver gang en matrise operasjon blir kalt blir den utført på den gjeldene matrisen. De forskjellige operasjonene er standard matrise operasjoner, hvor matrisen blir multiplisert med en operasjons matrise.

\begin{equation}
glRotate(\theta	,x,y,z)  = \begin{bmatrix}
1 & 0&  0 &0 \\
0   &\cos \theta &  -\sin \theta &0\\
0 &  \sin \theta   & \cos \theta &0\\
0&0&0&1
\end{bmatrix} * \begin{bmatrix}
\cos \theta  & 0 &  \sin \theta &0\\
0  & 1  & 0 & 0\\
-\sin \theta &  0 &  \cos \theta  &0\\
0&0&0&1
\end{bmatrix} 
*
\begin{bmatrix}
\cos \theta & -\sin \theta &   0 &0\\[3pt]
\sin \theta & \cos \theta  & 0 &0\\[3pt]
0 &0 & 1 &0\\
0&0&0&1\\
\end{bmatrix}
\end{equation}
\begin{equation}
glScale(x,y,z)=
\begin{bmatrix}
x &0&0&0\\
0&y&0&0\\
0&0&x&0\\
0&0&0&1
\end{bmatrix}
\end{equation}
\begin{equation}
glTranslate(x,y,z)=
\begin{bmatrix}
1 &0&0&x\\
0&1&0&y\\
0&0&1&z\\
0&0&0&1
\end{bmatrix}
\end{equation}

For å lage og dytte ut matriser på stakken brukes glPushMatrix() og glPopMatrix(). Når du har hentet ut en matrise kan du utføre rutiner på denne. Modellmatrisen er den mest essensielle matrisen, her kan du utføre rutiner som å tegne streker, polygoner og lignende. 




\section*{Programmet} 

\subsection*{Bruk}
\subsubsection*{Installasjon }
\subsubsection*{Input filen}


\subsection*{Fortran}
\subsubsection*{Struktur}
\subsubsection*{Program-analyse}
\subsubsection*{Optimaliseringer}
\subsubsection*{Tidsbruk}
\subsubsection*{Resultater}



\subsection*{C}

\subsubsection*{Struktur}
\subsubsection*{Optimaliseringer}
\subsubsection*{Tidsbruk}
\subsubsection*{Visualisering}




\subsection*{Fargefunksjon}
En fargefunksjon er en funksjon genererer en farge basert på en verdi. Den kan for eksempel returene en rgb verdi. Fargemodellen rgb baserer seg på og blande, blå, grønn og rød, til ønsket farge. 


\section*{Diskusjon}

hvorfor jeg valte ting: gauss, innpt stdin

\section*{Konklusjon}

lærte nytt tankemønster ved å programere funksjonelt

\paragraph{} 


\begin{thebibliography}{9}

\bibitem{wikinastran}
  Wikipedia,
  \url{http://en.wikipedia.org/wiki/Finite_element_method}
  

\bibitem{waloen}
  Åge Ø. Waløen,
  1995, 
  Dimensjonering ved hjelp av elementmetoden, NTNU
 
\bibitem{FEM}
	Dyryl L. Logen, 2011, A First Course in the Finite Element Method
	
\bibitem{kreyzig}
Erwin Kreyszig, 2006, Advanced Engineering Mathematics, 9th Edition

\end{thebibliography}

\end{document}

  Det er en del måter å implementere gauss på. Jeg valgte å bruke partiell pivotering, hvor en eliminerer rad for rad men et såkalt pivot element. Dette elementet bør være så stort som mulig for å minske avrundingsfeil. 